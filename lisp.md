---
title: Electric Lisp
author: Matthew Blount
language: en-US
---
# Introduction
## Vau, the Ultimate Lambda
The lambda calculus is like Minecraft for programming language
designers. Many games let you build things, but Minecraft lets you
build them out of a single, fundamental unit: the "voxel", a three
dimensional block representing wood, stone, ice, or anything else you
can imagine. This uniform structure is a simplifying feature:
explaining the entire world (or as much of it as possible) with
reference to a single abstraction gives you maximum leverage for your
cognitive effort. A vast and rich space of combinatorial interactions
opens up, not because you painstakingly crafted each one, but because
they can't *help* but interact due to their uniform treatment.

The lambda calculus is like that. Many languages let you write
programs, but the lambda calculus lets you write them out of a single,
fundamental unit: the "function", a rule for transforming one object
in to another. This uniform structure is a simplifying feature: many
common language constructs, such as recursion, iteration, compound
data and exception handling, can all be implemented in terms of
functions, and functions in terms of the lambda expression:

[picture of expression, description of parts, 2-3 paragraphs]

The difference between the lambda calculus and Lisp is like the
difference between a number and a numeral. A `lambda` expression
receives a number as an argument; a `vau` expression receives a
*numeral* as an argument, along with the local context that may or may
not assign a number to that numeral.

# Syntax

# Semantics
## Symbols
## Numbers
## Strings
## Cases
## Unit
## Pairs
## Scopes
## Procedures
### Primitives
### Operatives
### Applicatives
### Combinators

# Effective Lisp
## Terminology
## Naming
## API Design

# Emacs Integration

# Comparison
## Scheme
## Kernel
## Common Lisp
## Emacs Lisp

# FAQ
