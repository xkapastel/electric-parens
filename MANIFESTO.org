#+BEGIN_QUOTE
Humans matter, not machines

Any technology that can make programming

- more accessible to large numbers of people, even in limited "Turing
  non-complete" form, and

- makes it possible to organize large and complex systems that are
  robust

will spread more rapidly than hard-to-use math-in-the-clouds
technology. Only a mathematical mind imagines a utopia in which all
programs are proved correct before they are released into the wild.

Such a technology must eliminate aspects of programming at which
humans suck:

- The archaic idea that humans should type source code into
  computers. As speech recognition and computer vision make progress,
  fewer people will find it necessary to know how to type. Programming
  will adapt, and it sure won't be in the form of dictating ASCII
  symbols to Siri.

- The idea that programming is like writing proofs cannot succeed on
  large scale for the simple reason that humans are more like monkeys
  and less like mathematicians (except for those mathematicians who
  are monkeys). Therefore, programming will take on a much more
  "organic" feel: programming by example, programming with help of
  machine learning, visual programming, recombining existing
  of-the-shelf blocks, etc.

- Programs have to be made robust. They have to become more like
  auto-parts that can be thrown around, and less like delicate
  snow-flakes that melt when humans touch them. Javascript is a bit
  like that, try finding a major web page which does not give any
  Javascript errors, yet it still "works".

- Humans are good at high-level organization and bad at attending to
  technical details that can go wrong. Programming has to done at high
  level, which does not involve technicalities such as interfacing
  with other systems, speech recognition, computer vision, user
  interfaces, data storage and retrieval, and communication. Primitive
  attempts in this directions are at present known as "SDKs",
  "standard libraries" and "operating systems". These concepts will
  still be around, but they will be somewhere in the background and
  the typical programmer will not have to access such low-level
  programming.

Of course, there will be low-level programming of the kind we know
today, but the vast majority of programmers will not know the first
thing about it. Typing discipline, computational effects, parallelism,
and other topics discussed by the current PL community will be
considered arcane. Future programmers will not know about them any
more than today's programmers know about the details of CPU registers
or the details of the Java Virtual Machine.

I have no idea how we are going to deal with complexity, but I think
network analysis, machine learning and ecology will govern large-scale
organization of software, not today's software engineers because their
methods are not organic enough for the kind of environment we are
heading to.

Let me end with a simile. Even just 15 years ago machine learning and
data mining used to be a specialist areas in computer science. They
were so successful that today we have something called "Data Science",
with conferences and people using of-the-shelf tools to analyze gobs
of data, even though they are not computer scientits or
statisticians. They are "specialists" who have been trained to
"analyze data", of course, but they are coming out of economics and
humanities departments. They do not want to know how clustering works,
they just do clustering. They are soon going to dwarf the "real"
machine learning community, and that is going to change the way
machine learning is percieved.

The same is going to happen to programming, because there is no limit
on demand for new software. Programming "specalists" who are not
"true" programmers by today's standards will crop up. They will just
get things done with computers, they won't "write code". They will
dictate trends and fashions in programming, not those few specialists
who know how to use keyboards and who actually understand what is
under the hood.

By andrejbauer at Sat, 2012-12-22 18:18
#+END_QUOTE
